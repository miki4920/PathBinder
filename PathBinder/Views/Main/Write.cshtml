@{
    ViewData["Title"] = "Write";
}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css" />
<link rel="stylesheet" href="~/css/write.css" />
<section>
    <div id="writeAreaHolder">
        <nav>
            <div id="buttonContainer">
                <button id="save" onclick="animateSaving()"><i class="fa-solid fa-floppy-disk"></i>Save</button>
                <button onclick="promptForURL()"><i class="fa-solid fa-globe"></i>Import</button>
                <button onclick="promptForFile()"><i class="fa-solid fa-file-import"></i>Foundry</button>
                <button onclick="printDocument()"><i class="fa-solid fa-print"></i>Print</button>
            </div>
            <div class="dropdown">
                <button class="dropdownButton"><i class="fa-solid fa-bars"></i>Elements</button>
                <div class="dropdownContainer hidden">
                </div>
            </div>
        </nav>
        <div id="writeArea">
    </div>
    </div>
    <div class="resizer"></div>
    <div id="displayAreaHolder"></div>
</section>
<script src="~/lib/jquery/dist/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/markdown/markdown.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/search/searchcursor.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/search/search.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/dialog/dialog.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/search/jump-to-line.min.js"></script>
<script src="https://unpkg.com/showdown/dist/showdown.min.js"></script>
<script>
    const paragraphElements = {
        "image": { "html": "img", "classes": ["image"] },
        "frame": { "html": "img" },
        "title": { "html": "h1", "classes": ["wide", "title"] },
        "header": { "html": "header", "classes": ["wide", "subtitle"] },
        "line": { "html": "p", "classes": ["line"] },
        "paragraph": { "html": "p", "classes": ["paragraph"] },
        "linebreak": { "html": "div", "classes": ["linebreak"] },
        "columnbreak": { "html": "div", "classes": ["break"] },
        "passive": { "html": "img", "src": "../assets/passive.png", "classes": ["action", "oneaction"] },
        "freeaction": { "html": "img", "src": "../assets/freeaction.png", "classes": ["action", "oneaction"] },
        "oneaction": { "html": "img", "src": "../assets/oneaction.png", "classes": ["action", "oneaction"] },
        "twoaction": { "html": "img", "src": "../assets/twoaction.png", "classes": ["action", "twoaction"] },
        "threeaction": { "html": "img", "src": "../assets/threeaction.png", "classes": ["action", "threeaction"] },
        "reaction": { "html": "img", "src": "../assets/reaction.png", "classes": ["action", "oneaction"] },
        "tag": { "html": "div", "classes": ["tag"] },
        "label": { "html": "div", "classes": ["label"] },
        "artist": { "html": "div", "classes": ["artist"] },
        "table": { "html": "table", "classes": ["table"] }
    }
    $("#displayAreaHolder").on("scroll", function () {
        localStorage.setItem("PathBinder-Scroll", $("#displayAreaHolder").scrollTop());
    });
    CodeMirror.defineMode("mustacheHighlight", function (config, parserConfig) {
        return {
            token: function (stream, state) {
                if (stream.match("{{") || stream.match("}}")) {
                    return "mustache-brackets";
                }

                if (stream.match(/^#/) || stream.match(/^\*/)) {
                    return "mustache-markdown";
                }

                if (stream.string.charAt(stream.start - 2) === '{' || stream.string.charAt(stream.start - 4) === '{') {
                    if (stream.match(/^[^\s{}]+/)) {
                        return "mustache-firstWord";
                    }
                }

                stream.next();
                return null;
            }
        };
    });
    const editor = CodeMirror(document.getElementById("writeArea"), {
        lineNumbers: true,
        lineWrapping: true,
        styleActiveLine: true,
        matchBrackets: true,
        theme: "default",
        mode: "mustacheHighlight",
        scrollbarStyle: "native",
        extraKeys: {
            "Ctrl-F": "findPersistent",
            "Shift-Enter": "findPrev",
            "Esc": "clearSearch",
            "Enter": function (cm) {
                if (cm?.state?.search?.query) {
                    cm.execCommand("findNext");
                } else {
                    cm.replaceSelection("\n", "end");
                }
            },
            "Ctrl-B": function (cm) {
                toggleWrapSelection(cm, "**");
            },
            "Ctrl-I": function (cm) {
                toggleWrapSelection(cm, "*");
            }
        }
    });
    editor.addOverlay({ name: "mustacheHighlight" });
    let autosaveTimeout;
    editor.on('change', function () {
        if (autosaveTimeout) {
            clearTimeout(autosaveTimeout);
        }
        let saveButton = document.getElementById('save');
        saveButton.innerHTML = '<i class="fa-solid fa-floppy-disk"></i> Save';
        saveButton.disabled = false;
        autosaveTimeout = setTimeout(animateSaving, 5000);
    });
    const displayArea = document.getElementById("displayAreaHolder");
    const converter = new showdown.Converter();
    const shadow = displayArea.attachShadow({ mode: "open" });
    let pageStyle = null;
    fetch('/css/page.css')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok' + response.statusText);
            }
            return response.text();
        })
        .then(css => {
            pageStyle = document.createElement('style');
            pageStyle.textContent = css;
            editor.on("change", function () {
                displayChange();
                $("#displayAreaHolder").scrollTop(localStorage.getItem("PathBinder-Scroll"));
            });
            
        })
        .catch(error => {
            console.error('Fetch error: ', error);
        });

    function toggleWrapSelection(cm, wrapper) {
        const selection = cm.getSelection();
        const cursorPosFrom = cm.getCursor("from");
        const cursorPosTo = cm.getCursor("to");

        const isWrapped = selection.startsWith(wrapper) && selection.endsWith(wrapper);

        if (isWrapped) {
            const unwrappedSelection = selection.slice(wrapper.length, -wrapper.length);
            cm.replaceSelection(unwrappedSelection);
            cm.setSelection(
                { line: cursorPosFrom.line, ch: cursorPosFrom.ch },
                { line: cursorPosTo.line, ch: cursorPosTo.ch - 2 * wrapper.length }
            );
        } else {
            cm.replaceSelection(wrapper + selection + wrapper);
            cm.setSelection(
                { line: cursorPosFrom.line, ch: cursorPosFrom.ch },
                { line: cursorPosTo.line, ch: cursorPosTo.ch + 2 * wrapper.length }
            );
        }
    }

    function cleanContent(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        const allElements = doc.querySelectorAll('*');
        allElements.forEach(element => {
            const firstChild = element.firstChild;
            if (firstChild && firstChild.nodeType === Node.TEXT_NODE && !firstChild.textContent.trim()) {
                element.remove();
            }
        });

        const actionSpans = doc.querySelectorAll('span[class*="action"]');
        actionSpans.forEach(span => {
            let content = span.textContent.trim();
            content = content.replace(/[-\[\]]/g, '');

            if (content.endsWith('s')) {
                content = content.slice(0, -1);
            }
            const replacementText = `{{${content}}}`;

            const textNode = document.createTextNode(replacementText);
            span.parentNode.replaceChild(textNode, span);
        });

        const anchors = doc.querySelectorAll('a');
        anchors.forEach(anchor => {
            const text = document.createTextNode(anchor.textContent);
            anchor.parentNode.replaceChild(text, anchor);
        })

        const bElements = doc.querySelectorAll('b');
        bElements.forEach(b => {
            const content = b.textContent.trim();

            const replacementText = `**${content}** `;

            const textNode = document.createTextNode(replacementText);
            b.parentNode.replaceChild(textNode, b);
        });

        const h1Elements = doc.querySelectorAll('h1');
        h1Elements.forEach(h1 => {
            const firstChildContent = h1.childNodes[0] ? h1.childNodes[0].textContent.trim() : '';
            const secondChildContent = h1.childNodes[1] ? h1.childNodes[1].textContent.trim() : '';

            const replacementText = `#### ${firstChildContent} {{label ${secondChildContent}}}\n`;

            const textNode = document.createTextNode(replacementText);
            h1.parentNode.replaceChild(textNode, h1);
        });



        const spanWithTagClass = doc.querySelectorAll('span[class*="trait"]');
        spanWithTagClass.forEach(span => {
            const content = span.textContent.trim();

            const replacementText = `{{tag ${content}}}\n`;

            const textNode = document.createTextNode(replacementText);
            span.parentNode.replaceChild(textNode, span);
        });

        const spans = doc.querySelectorAll('span');
        spans.forEach(span => {
            const content = span.innerHTML.trim();
            const replacementHTML = `<br>${content}`;
            span.outerHTML = replacementHTML;
        });

        const hrElements = doc.querySelectorAll('hr');
        hrElements.forEach(hr => {
            const replacementHTML = '<br>{{linebreak}}<br>';
            hr.outerHTML = replacementHTML;
        });

        const brElements = Array.from(doc.querySelectorAll('br'));

        brElements.forEach((br, index) => {
            if (index < brElements.length) { 
                const nextBr = brElements[index + 1];
                let contentNodes = [];
                let currentNode = br.nextSibling;
                while (currentNode && currentNode !== nextBr) {
                    contentNodes.push(currentNode);
                    currentNode = currentNode.nextSibling;
                }
                const content = contentNodes.map(node => node.textContent).join('').trim();
                if (content) {
                    const replacement = document.createTextNode(`{{line ${content}}}\n`);
                    doc.body.insertBefore(replacement, br);
                    contentNodes.forEach(node => node.remove());
                }
            }
            br.remove();
        });

        let content = doc.body.innerHTML;

        while (content.includes('{{line {{linebreak}}}}')) {
            content = content.replace('{{line {{linebreak}}}}', '{{linebreak}}');
        }

        doc.body.innerHTML = content;

        return doc.body.innerHTML;
    }

    function extractContent(content) {
        const titleElements = content.querySelectorAll('h1');
        const secondTitle = titleElements[1] === undefined ? titleElements[0] : titleElements[1];
        let currentNode = secondTitle.nextSibling;
        let extractedContent = secondTitle.outerHTML;
        while (currentNode) {
            if (currentNode.tagName === "H3") {
                const isLegacyContent = currentNode.textContent.toLowerCase().includes("legacy content");
                if (isLegacyContent) {
                    currentNode = currentNode.nextSibling;
                    continue;
                }
                else {
                    break;
                }
            }
            else if (["H1", "H2", "H4", "H5", "H6"].includes(currentNode.tagName) || !currentNode.nextSibling) {
                break;
            }
            extractedContent += currentNode.outerHTML ? currentNode.outerHTML : currentNode.textContent;
            currentNode = currentNode.nextSibling;
        }

        return cleanContent(extractedContent);
    }

    function replaceContent(content) {
        const cursorPosition = editor.getCursor();
        editor.replaceRange(content, cursorPosition);
    }

    async function processURL(url) {
        const serverEndpoint = '@Url.Action("PostImport", "Import")';
        const localStorageKey = `archive-${url}`;
        const parser = new DOMParser();

        let content = localStorage.getItem(localStorageKey);
        if (content) {
            content = parser.parseFromString(content, 'text/html');
        }
        else {
            try {
                const response = await fetch(serverEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ Url: url })
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                let data = await response.text();
                data = parser.parseFromString(data, 'text/html');
                let element = data.getElementById('ctl00_RadDrawer1_Content_MainContent_DetailedOutput');
                localStorage.setItem(localStorageKey, element.innerHTML);
                content = element;
            } catch (error) {
                console.error('There was a problem with the fetch operation:', error.message);
            }
        }
        content = extractContent(content);
        replaceContent(content);

    }

    function promptForURL() {
        const url = prompt("Please enter a URL from Archives of Nethys:");
        if (url) {
            processURL(url);
        }
    }

    function processJsonData(creatureData) {
        const output = [];
        const sizeMappings = {
            tiny: "Tiny",
            sml: "Small",
            med: "Medium",
            lg: "Large",
            huge: "Huge",
            grg: "Gargantuan"
        };
        const alignmentTags = ["chaotic", "evil", "lawful", "good", "neutral"];

        output.push(formatCreatureLabel(creatureData));
        output.push(...formatTraits(creatureData, alignmentTags));
        output.push(formatSize(creatureData, sizeMappings));
        output.push(formatPerception(creatureData));
        output.push(formatLanguages(creatureData));
        output.push(formatSkills(creatureData));
        output.push(formatAbilities(creatureData));
        output.push(...formatItems(creatureData));
        output.push(formatLinebreak());
        output.push(formatDefenses(creatureData));
        output.push(formatHP(creatureData));
        output.push(formatLinebreak());
        output.push(formatSpeeds(creatureData));
        output.push(formatResistances(creatureData));
        output.push(formatImmunities(creatureData));
        output.push(formatWeaknesses(creatureData));
        output.push(...formatMelee(creatureData));
        output.push(...formatRanged(creatureData));
        output.push(...formatActions(creatureData));

        return output.join('\n');
    }

    function formatCreatureLabel(creatureData) {
        return `#### ${creatureData.name} {{label Creature ${creatureData.system.details.level.value}}}`;
    }

    function formatTraits(creatureData, alignmentTags) {
        return creatureData.system.traits.value.filter(trait => !alignmentTags.includes(trait))
            .map(trait => `{{tag ${capitalizeFirstLetter(trait)}}}`);
    }

    function formatSize(creatureData, sizeMappings) {
        const sizeValue = creatureData.system.traits.size.value;
        return sizeValue ? `{{tag ${sizeMappings[sizeValue]}}}` : '';
    }

    function formatPerception(creatureData) {
        const senses = creatureData.system.perception.senses.map(sense => sense.type).join(', ');
        return `{{line **Perception**  +${creatureData.system.perception.mod}; ${senses}}}`;
    }

    function formatLanguages(creatureData) {
        const languages = creatureData.system.details.languages.value.join(', ');
        return `{{line **Languages**  ${languages}}}`;
    }

    function formatSkills(creatureData) {
        const skills = creatureData.items.filter(item => item.type === 'lore')
            .map(skill => `${skill.name} +${skill.system.mod.value}`).join(', ');
        return skills ? `{{line **Skills**  ${skills}}}` : '';
    }

    function formatAbilities(creatureData) {
        const { str, dex, con, int, wis, cha } = creatureData.system.abilities;
        return `{{line **Str**  ${formatBonus(str.mod)}, **Dex**  ${formatBonus(dex.mod)}, **Con**  ${formatBonus(con.mod)}, **Int**  ${formatBonus(int.mod)}, **Wis**  ${formatBonus(wis.mod)}, **Cha**  ${formatBonus(cha.mod)}}}`;
    }

    function formatItems(creatureData) {
        return creatureData.items.filter(item => ['weapon', 'armor'].includes(item.type))
            .map(item => `{{line **Items**  ${item.name}}}`);
    }

    function formatLinebreak() {
        return '{{linebreak}}';
    }

    function formatDefenses(creatureData) {
        return `{{line **AC**  ${creatureData.system.attributes.ac.value}; **Fort**  +${creatureData.system.saves.fortitude.value}, **Ref**  +${creatureData.system.saves.reflex.value}, **Will**  +${creatureData.system.saves.will.value}}}`;
    }

    function formatHP(creatureData) {
        return `{{line **HP**  ${creatureData.system.attributes.hp.value}}}`;
    }

    function formatSpeeds(creatureData) {
        const speeds = creatureData.system.attributes.speed?.otherSpeeds.map(speed => `${speed.type} ${speed.value} ft.`).join(', ');
        return speeds ? `{{line **Speed**  ${speeds}}}` : '';
    }

    function formatResistances(creatureData) {
        const resistances = creatureData.system.attributes?.resistances?.map(resistance => {
            const exceptions = resistance.exceptions ? ` (except ${resistance.exceptions.join(', ')})` : '';
            return `${resistance.type}${resistance.value ? ` ${resistance.value}` : ''}${exceptions}`;
        }).join('; ');
        return resistances ? `{{line **Resistances**  ${resistances}}}` : '';
    }

    function formatImmunities(creatureData) {
        const immunities = creatureData.system.attributes?.immunities?.map(immunity => immunity.type).join(', ');
        return immunities ? `{{line **Immunities**  ${immunities}}}` : '';
    }

    function formatWeaknesses(creatureData) {
        const weaknesses = creatureData.system.attributes?.weaknesses?.map(weakness => `${weakness.type} ${weakness.value}`).join('; ');
        return weaknesses ? `{{line **Weaknesses**  ${weaknesses}}}` : '';
    }

    function formatMelee(creatureData) {
        return creatureData.items.filter(item => item.type === 'melee').map(melee => formatCombat(melee, false));
    }

    function formatRanged(creatureData) {
        return creatureData.items.filter(item => item.type === 'melee' && item.system.weaponType.value === 'ranged')
            .map(ranged => formatCombat(ranged, true));
    }

    function formatActions(creatureData) {
        const actionSymbols = {
            action: "{{oneaction}} ",
            free: "{{freeaction}} ",
            reaction: "{{reaction}} ",
            passive: ""
        };

        return creatureData.items.filter(item => item.type === 'action')
            .map(action => {
                const actionSymbol = getActionSymbol(action, actionSymbols);
                return formatActionText(action, actionSymbol);
            });
    }

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function formatCombat(combatItem, isRanged) {
        const dmg = Object.values(combatItem.system.damageRolls)[0];
        const traits = combatItem.system.traits.value.map(trait => trait.startsWith('reach-') ? `reach ${trait.split('-')[1]} feet` : trait).join(", ");
        const isAgile = combatItem.system.traits.value.includes('agile');
        const penalty = isAgile ? 4 : 5;
        const secondPenalty = isAgile ? 8 : 10;
        const adjustedBonus = combatItem.system.bonus.value;
        const firstAdjustedBonus = adjustedBonus - penalty;
        const secondAdjustedBonus = adjustedBonus - secondPenalty;
        return `{{line **${isRanged ? "Ranged" : "Melee"}**   {{oneaction}}  ${combatItem.name} ${formatBonus(adjustedBonus)} [${formatBonus(firstAdjustedBonus)}/${formatBonus(secondAdjustedBonus)}] \\(${traits}), **Damage**  ${dmg.damage} ${dmg.damageType}}}`;
    }

    function formatBonus(bonus) {
        return `${bonus >= 0 ? '+' : ''}${bonus}`;
    }

    function getActionSymbol(action, actionSymbols) {
        let symbol = actionSymbols[action.system.actionType.value] || "";
        if (action.system.actionType.value === "action" && action.system.actions.value) {
            const actionCount = action.system.actions.value;
            symbol = actionCount === 2 ? "{{twoaction}} " : actionCount === 3 ? "{{threeaction}} " : symbol;
        }
        return symbol;
    }

    function formatActionText(action, actionSymbol) {
        let actionText = action.system.description.value;
        actionText = cleanHtmlTags(actionText);
        return `{{line **${action.name}** ${actionSymbol}${actionText}}}`;
    }

    function cleanHtmlTags(htmlString) {
        return htmlString.replace(/<(b|strong)>(\s*)([\s\S]+?)(\s*)<\/\1>/gi, function (match, tag, leadingSpace, text, trailingSpace) {
            return `**${text.trim()}**`;
        })
            .replace(/(^|\s)(\*\*)(\S)/g, '$1$2 $3')
            .replace(/(\S)(\*\*)(\s|$)/g, '$1 $2$3')
            .replace(/<\/?[^>]+>/g, "")
            .replace(new RegExp("@@Damage\\[(\\d+d\\d+)\\[([^\\]]+)\\]\\]", "gi"), "$1 $2")
            .replace(new RegExp("@@Check\\[type:(\\w+)\\|dc:(\\d+)(\\|basic:true)?\\]", "gi"), function (match, type, dc, basic) {
                return `DC ${dc} ${basic ? 'basic ' : ''}${type.charAt(0).toUpperCase() + type.slice(1)} ${basic ? '' : 'save'}`
            })
            .replace(/@@(\{[^}]*\})/g, "$1")
            .replace(/@@\w+\[[^\]]*\]/g, "")
            .replace(/@@[^\s{]+/g, "")
            .replace(/{([^}]*)}/g, "$1")
            .replace(/\[\[[^\]]*\]\]/g, "")
            .replace(/(\*\*)(\s*)(.*?)(\s*)(\*\*)/g, function (match, startBold, leadingSpace, text, trailingSpace, endBold) {
                return `${startBold}${text.trim()}${endBold}`;
            })
    }

    function promptForFile() {
        let fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'application/json';
        fileInput.onchange = e => {
            let file = e.target.files[0];
            if (!file) {
                return;
            }
            let reader = new FileReader();
            reader.onload = e => {
                try {
                    let jsonData = JSON.parse(e.target.result);
                    replaceContent(processJsonData(jsonData));
                } catch (error) {
                    console.error('Error parsing JSON file:', error);
                }
            };
            reader.readAsText(file);
        };
        fileInput.click();
    }

    function replacePlaceholders(placeholder, page, wrapper) {
        // Remember that classes need to be in a list, even if only one element
        const regex = /([a-zA-Z]+)(:*)([\s\S]*?)(?:\[(.*?)\])?$/g;
        const elements = paragraphElements;
        placeholder = placeholder.replace(regex, function (match, elementName, indentMarkers, content, attributes) {
            let margin = indentMarkers.length;

            let element = elements[elementName];
            if (element === undefined) {
                return match;
            }

            let newElement;
            if (element["html"]) {
                newElement = document.createElement(element["html"]);
            }
            if (element["src"] !== undefined) {
                newElement.src = element["src"];
            }
            else if (element["html"] === "img") {
                newElement.src = content.trim();
            } 
            else if (elementName === "table") {
                const rows = content.trim().split('\n');
                const headers = rows[0].split(',').map(header => header.trim());
                const tbody = document.createElement('tbody');
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');

                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.innerHTML = header;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                newElement.appendChild(thead);

                for (let i = 1; i < rows.length; i++) {
                    const row = document.createElement('tr');
                    rows[i].split(',').map(cell => cell.trim()).forEach(cellValue => {
                        const td = document.createElement('td');
                        td.innerHTML = cellValue;
                        row.appendChild(td);
                    });
                    tbody.appendChild(row);
                }
                newElement.appendChild(tbody);
            }
            else {
                newElement.innerHTML = content.trim();
            }

            element["classes"]?.forEach(className => {
                newElement.classList.add(className);
            });

            let shouldAttach = false;

            if (newElement && attributes) {
                const attrs = attributes.split(',').map(attr => attr.trim().split('='));
                attrs.forEach(([key, value]) => {
                    if (key === "class" && value === "attach") {
                        shouldAttach = true
                    }
                    else if (key === "class" && value) { 
                        newElement.classList.add(value);
                    }
                    else if (elementName === "table" && key === "headerBackground") {
                        newElement.style.setProperty('--header-bg-color', value);
                    }
                    else if (elementName === "table" && key === "headerColor") {
                        newElement.style.setProperty('--header-color', value);
                    }
                    else { 
                        newElement.style[key] = value;
                    }
                });
            }

            if (elementName === "frame") {
                let pageElement = document.createElement(element["html"]);
                pageElement.src = `../assets/page.png`
                pageElement.classList.add(elementName);
                pageElement.style.padding = newElement.style.padding;
                newElement.src = content.trim();
                newElement.style.padding = 0;
                page.appendChild(newElement);
                page.appendChild(pageElement);
                wrapper.style.margin = `${parseFloat(pageElement.style.padding) + 0.5}cm`;
                let marginInMM = (parseFloat(pageElement.style.padding) + 0.5) * 10;
                wrapper.style.width = `${(210 - 2 * marginInMM)}mm`; 
                wrapper.style.height = `${(297 - 2 * marginInMM)}mm`; 
                newElement = "";
            }
             
            if (margin > 0) {
                newElement.style.marginLeft = `${margin}em`;
            }

            if (shouldAttach) {
                page.appendChild(newElement);
                newElement = null;
            }

            return newElement ? newElement.outerHTML : "";
        });

        return placeholder;
    }

    function replaceBrackets(text, page, wrapper) {
        text = text.replace(/<\/?p>/g, "");
        let index = 0;
        function processSegment() {
            let content = '';
            while (index < text.length) {
                if (text[index] === '{' && text[index + 1] === '{') {
                    index += 2;
                    content += processSegment();
                } else if (text[index] === '}' && text[index + 1] === '}') {
                    index += 2;
                    return replacePlaceholders(content, page, wrapper);
                } else {
                    content += text[index++];
                }
            }
            return content;
        }
        text = processSegment()
        let lines = text.split('\n');
        let processedLines = lines.map(line => {
            if (line.trim() === "" || (line.startsWith('<') && !line.startsWith('<strong') && !line.startsWith('<b') && !line.startsWith('<em') && !line.startsWith('<i'))) {
                return line;
            } else {
                return replacePlaceholders("line " + line, page, wrapper);
            }
        });
        return processedLines.join('\n');
    }

    function applyClasses(content, selectors, className) {
        selectors.forEach(selector => {
            content.querySelectorAll(selector).forEach(element => {
                element.classList.add(className);
            });
        });
       
    }

    function createElementWithClass(tagName, className) {
        const element = document.createElement(tagName);
        element.classList.add(className);
        return element;
    }

    function displayChange() {
        shadow.innerHTML = "";
        let htmlContent = editor.getValue();
        htmlContent = htmlContent.split("\{\{pagebreak\}\}");
        for (let element of htmlContent) {
            let page = createElementWithClass("div", "page");
            let columnWrapper = createElementWithClass("div", "columnWrapper");
            element = converter.makeHtml(element);
            columnWrapper.innerHTML = replaceBrackets(element, page, columnWrapper);
            applyClasses(columnWrapper, ["h1", "subtitle"], "wide");
            columnWrapper.innerHTML = columnWrapper.innerHTML.replace(/<p><\/p>|}}/gm, "");
            page.appendChild(columnWrapper);
            shadow.appendChild(page); 
        }
        let currentlyOpenUid = JSON.parse(localStorage.getItem('currentlyOpen'));
        let existingDocumentData = JSON.parse(localStorage.getItem(currentlyOpenUid));
        existingDocumentData.cover = shadow.children[0].style.backgroundImage;
        localStorage.setItem(currentlyOpenUid, JSON.stringify(existingDocumentData));
        shadow.appendChild(pageStyle);
        
    }
    
    function animateSaving() {
        let saveButton = document.getElementById('save');
        if (!saveButton.disabled) {
            saveButton.innerHTML = '<i class="fa-solid fa-floppy-disk"></i> Saving...';
            saveDocument();
            setTimeout(() => {
                saveButton.innerHTML = '<i class="fa-solid fa-floppy-disk"></i> Saved';
                saveButton.disabled = true;
            }, 500);
        } 
    }

    function saveDocument() {
        let content = editor.getValue();
        let currentlyOpenUid = JSON.parse(localStorage.getItem('currentlyOpen'));
        let existingDocumentData = JSON.parse(localStorage.getItem(currentlyOpenUid));
        existingDocumentData.content = content;
        localStorage.setItem(currentlyOpenUid, JSON.stringify(existingDocumentData));
    }

    function getDocument() {
        let uid = JSON.parse(localStorage.getItem('currentlyOpen'));
        if (uid !== null) {
            let doc = localStorage.getItem(uid);
            if (doc !== null) {
                doc = JSON.parse(doc);
                editor.setValue(doc.content);
            } else {
                alert("Document not found!");
            }
        } else {
            alert("No document currently open!");
        }
    }

    function printDocument() {
        saveDocument()
        document.querySelectorAll('head link[rel="stylesheet"]').forEach((link) => {
            if (!link.href.endsWith('/css/site.css')) {
                shadow.appendChild(link.cloneNode());
            }
        });
        let printStyle = document.createElement("style");
        printStyle.textContent = `
        html { margin: 0!important; }
        body { margin: 0!important; }
        .page { margin: 0!important; }
    `;
        let printWindow = window.open('', '_blank');
        printWindow.document.head.appendChild(printStyle);
        printWindow.document.body.innerHTML = shadow.innerHTML;;
        printWindow.document.close(); 
        printWindow.focus();
        printWindow.print();
    }

    const config = { minColumnWidth: 200, resizerSelector: ".resizer", mainSectionSelector: "section" };
    const state = { isResizing: false, initialX: null, initialWidths: null };
    const elements = {
        resizer: document.querySelector(config.resizerSelector),
        main: document.querySelector(config.mainSectionSelector)
    };

    elements.resizer.addEventListener("mousedown", e => {
        state.isResizing = true;
        state.initialX = e.clientX;
        state.initialWidths = getInitialWidths();
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
    });

    function getInitialWidths() {
        const styles = getComputedStyle(elements.main);
        const columns = styles.gridTemplateColumns.split(" ");
        return [parseInt(columns[0]), parseInt(columns[2])];
    }

    function onMouseMove(e) {
        if (!state.isResizing) return;
        const deltaX = e.clientX - state.initialX;
        const [newLeftWidth, newRightWidth] = updateWidths(deltaX);
        elements.main.style.gridTemplateColumns = `${newLeftWidth}px 20px ${newRightWidth}px`;
    }

    function updateWidths(deltaX) {
        let newLeftWidth = state.initialWidths[0] + deltaX;
        let newRightWidth = state.initialWidths[1] - deltaX;
        if (newLeftWidth < config.minColumnWidth) {
            newLeftWidth = config.minColumnWidth;
            newRightWidth = state.initialWidths[0] + state.initialWidths[1] - config.minColumnWidth;
        } else if (newRightWidth < config.minColumnWidth) {
            newRightWidth = config.minColumnWidth;
            newLeftWidth = state.initialWidths[0] + state.initialWidths[1] - config.minColumnWidth;
        }
        return [newLeftWidth, newRightWidth];
    }

    function onMouseUp() {
        state.isResizing = false;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
    }

    function applyElement(key) {
        console.log(key);
    }

    function fillDropdownContent() {
        const dropdownContainer = document.querySelector('.dropdownContainer');
        for (const [key, value] of Object.entries(paragraphElements)) {
            const button = document.createElement('button');
            button.textContent = key.charAt(0).toUpperCase() + key.slice(1);
            button.onclick = () => applyElement(key);
            dropdownContainer.appendChild(button);
        }
        const buttons = document.querySelectorAll(".dropdownButton");
        const targets = document.querySelectorAll(".dropdownContainer");
        buttons.forEach((button, index) => {
            const target = targets[index];
            button.addEventListener("click", function () {
                target.classList.toggle("visible");
                target.classList.toggle("hidden");
            });
        });
    }

    function applyElement(key) {
        const selectedText = editor.getSelection();
        if (selectedText) {
            const regex = /\{\{(.+?) (.+?)\}\}/g;
            let newText;

            if (regex.test(selectedText)) {
                newText = selectedText.replace(regex, `{{${key} $2}}`);
            } else {
                newText = `{{${key} ${selectedText}}}`;
            }

            const startPos = editor.getCursor("from");
            const endPos = editor.getCursor("to");

            editor.replaceSelection(newText);

            const newLines = newText.split('\n');
            const newEndLine = startPos.line + newLines.length - 1;
            const newEndCh = (newLines.length === 1) ?
                startPos.ch + newText.length :
                newLines[newLines.length - 1].length;

            const newEndPos = {
                line: newEndLine,
                ch: newEndCh
            };
            editor.setSelection(startPos, newEndPos);
        }
    }

    window.onload = (event) => {
        localStorage.setItem("PathBinder-Scroll", 0);
        fillDropdownContent()
        getDocument();
    };

    document.addEventListener('keydown', function (event) {
        if ((event.ctrlKey || event.metaKey) && event.key === 's') {
            event.preventDefault();
            animateSaving();
        }
    });
</script>
@section Scripts {
    @{
        await Html.RenderPartialAsync("_ValidationScriptsPartial");
    }
}