@{
    ViewData["Title"] = "Write";
}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css" />
<style>
    section {
        display: grid;
        flex-basis: 100%;
        grid-template-columns: 1fr 10px 1fr;
        background-color: rgb(249, 241, 223);
    }

    #writeAreaHolder {
        display: flex;
        overflow-y: auto;
    }

    #writeAreaHolder nav {
        flex: 1 1 auto;
        background-color: rgb(255, 255, 255);
        flex-direction: row;
        padding: 0;
    }

    button {
        cursor: pointer; 
        border: none;
        text-decoration: none;
        padding: 6px;
        flex-grow:0;
    }

    #writeArea, #displayAreaHolder {
        flex-direction: column;
        overflow-x: hidden;
        overflow-y: auto;
        color: rgb(70, 20, 19);
        flex-grow: 1;
    }

    #displayAreaHolder {
        padding: 0 10px;
    }

    #writeArea {
        font-family: monospace;
        line-height: 21px;
        overflow-y: auto;
        flex-basis: 100%;
    }

    .CodeMirror {
        height: 100%;
        background-color: rgb(249, 241, 223);
    }

    .resizer {
        cursor: ew-resize;
        background-color: rgb(18, 24, 32);
    }
</style>
<section>
    <div id="writeAreaHolder">
        <nav>
            <button onclick="postDocument()">Save</button>
        </nav>
        <div id="writeArea">
    </div>
    </div>
    <div class="resizer"></div>
    <div id="displayAreaHolder"></div>
</section>

<script src="~/lib/jquery/dist/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
<script src="https://unpkg.com/showdown/dist/showdown.min.js"></script>
<script>
    

    $("#displayAreaHolder").on("scroll", function () {
        localStorage.setItem("PathBinder-Scroll", $("#displayAreaHolder").scrollTop());
    });

    const editor = CodeMirror(document.getElementById('writeArea'), {
        lineNumbers: true,
        lineWrapping: true,
        styleActiveLine: true,
        matchBrackets: true,
        theme: 'default',
        mode: 'markdown',
        scrollbarStyle: "native"
    });

    const displayArea = document.getElementById('displayAreaHolder');
    const converter = new showdown.Converter();
    const shadow = displayArea.attachShadow({ mode: 'open' });
    const style = document.createElement("style");
    style.textContent = `
            .page {
                margin-top: 28px;
                margin-bottom: 28px;
                margin-left: auto;
                margin-right: auto;
                padding: 1.4cm 1.9cm 1.7cm;
                background-image: url(../assets/page.jpg);
                box-shadow: 1px 4px 14px #000;
            }

            .page, .columnWrapper {
                column-count: 2;
                column-fill: auto;
                height: 279.4mm;
                width: 215.9mm;
                overflow: hidden;
            }

            .page h1 {
                column-span: all;
            }

            .page p {
                margin: 0;
            }

            .columnWrapper {
                height: 279.4mm;
                column-count: inherit;
                column-span: all;

            }
        `;

    function createElementWithClass(tagName, className) {
        const element = document.createElement(tagName);
        element.classList.add(className);
        return element;
    }

    function updateDisplay() {
        let htmlContent = editor.getValue();
        let page = createElementWithClass("div", "page");
        let columnWrapper = createElementWithClass("div", "columnWrapper");
        columnWrapper.innerHTML = converter.makeHtml(htmlContent);
        shadow.innerHTML = "";
        page.appendChild(columnWrapper);
        shadow.appendChild(page);
        shadow.appendChild(style);

        const columnWrapperRect = columnWrapper.getBoundingClientRect()
        while (true) {
            let elements = Array.from(page.firstChild.children);
            let newPage = createElementWithClass("div", "page");
            let newColumnWrapper = createElementWithClass("div", "columnWrapper");
            newPage.appendChild(newColumnWrapper);
            let hasOverflowingElement = false;

            for (let element of elements) {
                const elemRect = element.getBoundingClientRect();
                if (elemRect.x > columnWrapperRect.x + columnWrapperRect.width) {
                    newColumnWrapper.appendChild(element);
                    hasOverflowingElement = true;
                }
            }
            if (!hasOverflowingElement) break;
            shadow.appendChild(newPage);
            elements = Array.from(page.firstChild.children);
            page = newPage;
        }
    }

    editor.on("change", () => {
        updateDisplay();
        if (localStorage.getItem("PathBinder-Scroll") != null) {
            $("#displayAreaHolder").scrollTop(localStorage.getItem("PathBinder-Scroll"));
        }
    });

    updateDisplay();

    async function postDocument() {
        try {

            const response = await fetch(window.location.href + "api/Document", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ "name": "miki4920", "content": editor.getValue() }),
            });

            if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
            }

            const jsonResponse = await response.json();
            console.log('Success:', jsonResponse);
        } catch (error) {
            console.error('Error:', error);
        }
    }

    async function getDocument() {
        try {
            const response = await fetch(window.location.href + "api/Document/1");

            if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
            }

            const documentData = await response.json();
            editor.setValue(documentData.content);
        } catch (error) {
            console.error('Error fetching document:', error);
        }
    }

    const config = { minColumnWidth: 200, resizerSelector: '.resizer', mainSectionSelector: 'section' };
    const state = { isResizing: false, initialX: null, initialWidths: null };
    const elements = {
        resizer: document.querySelector(config.resizerSelector),
        main: document.querySelector(config.mainSectionSelector)
    };

    elements.resizer.addEventListener('mousedown', e => {
        state.isResizing = true;
        state.initialX = e.clientX;
        state.initialWidths = getInitialWidths();
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });

    function getInitialWidths() {
        const styles = getComputedStyle(elements.main);
        const columns = styles.gridTemplateColumns.split(' ');
        return [parseInt(columns[0]), parseInt(columns[2])];
    }

    function onMouseMove(e) {
        if (!state.isResizing) return;
        const deltaX = e.clientX - state.initialX;
        const [newLeftWidth, newRightWidth] = updateWidths(deltaX);
        elements.main.style.gridTemplateColumns = `${newLeftWidth}px 10px ${newRightWidth}px`;
    }

    function updateWidths(deltaX) {
        let newLeftWidth = state.initialWidths[0] + deltaX;
        let newRightWidth = state.initialWidths[1] - deltaX;
        if (newLeftWidth < config.minColumnWidth) {
            newLeftWidth = config.minColumnWidth;
            newRightWidth = state.initialWidths[0] + state.initialWidths[1] - config.minColumnWidth;
        } else if (newRightWidth < config.minColumnWidth) {
            newRightWidth = config.minColumnWidth;
            newLeftWidth = state.initialWidths[0] + state.initialWidths[1] - config.minColumnWidth;
        }
        return [newLeftWidth, newRightWidth];
    }

    function onMouseUp() {
        state.isResizing = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    }

    window.onload = (event) => {
        getDocument();
    };
</script>
@section Scripts {
    @{
        await Html.RenderPartialAsync("_ValidationScriptsPartial");
    }
}